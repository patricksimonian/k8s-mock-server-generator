import {
  Storage,
  KubeResource,
  KubeList,
  Status,
  ListOptions,
  WatchOptions,
  WatchEventType,
  KubeScale,
  LogEntry,

} from "./Storage"; // Adjust import paths as needed
import { EventEmitter } from "events";
import { v4 as uuidv4 } from "uuid";
import { applyPatch } from "fast-json-patch";
import { isClusterScoped, createStatusFailure, matchesFieldSelector, matchesLabelSelector, merge, capitalize } from "../utils";
import { Readable } from "stream";

// ----------------------------------------------------------------
// Pagination: base64-encoded tokens with offset + resourceVersion
// ----------------------------------------------------------------
function createContinueToken(offset: number, resourceVersion: string): string {
  const payload = JSON.stringify({ offset, rv: resourceVersion });
  return Buffer.from(payload).toString("base64");
}

function parseContinueToken(token?: string): { offset: number; rv: string } | null {
  if (!token) return null;
  try {
    const decoded = Buffer.from(token, "base64").toString("utf8");
    const parsed = JSON.parse(decoded);
    if (typeof parsed.offset !== "number" || typeof parsed.rv !== "string") {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

// ----------------------------------------------------------------
// The main InMemoryStorage class
// ----------------------------------------------------------------
export class InMemoryStorage implements Storage {
  private initialized = false;
  private eventEmitter = new EventEmitter();
  private readonly defaultClusterName = "default_cluster";
  /**
   * data layout:
   *
   * {
   *   "__cluster__": {
   *      "node": { "<name>": KubeResource },
   *      "namespace": { "<name>": KubeResource },
   *      ...
   *   },
   *   "default": {
   *      "pods": { "<name>": KubeResource },
   *      "deployments": { "<name>": KubeResource },
   *      ...
   *   }
   * }
   */
  private data: Record<string, Record<string, Record<string, KubeResource>>> = {
    [this.defaultClusterName]: {}
  };

  private logStore: Record<string, Record<string, {
    stdout: LogEntry[];
    stderr: LogEntry[];
    emitter: EventEmitter;
  }>> = {
      [this.defaultClusterName]: {}
    };

  private getLogKey(namespace: string, podName: string, container: string): string {
    return `${namespace}/${podName}/${container}`;
  }

  private appendLogLine(logArray: LogEntry[], line: string, stream: 'stdout' | 'stderr'): void {
    const timestamp = new Date().toISOString();
    logArray.push({ line, timestamp, stream });
    if (logArray.length > this.MAX_LOG_LINES) {
      logArray.shift(); // remove the oldest line
    }
  }

  private readonly MAX_LOG_LINES = 1000;

  constructor() {
    this.eventEmitter.setMaxListeners(100);
  }

  // ---------------------------------------------------------------------------
  // Basic checks
  // ---------------------------------------------------------------------------
  async isInitialized(): Promise<boolean> {
    return this.initialized;
  }

  async markInitialized(): Promise<void> {
    this.initialized = true;
  }
  // ---------------------------------------------------------------------------
  // LOGS
  // ---------------------------------------------------------------------------
  async writeLogs(
    name: string,
    namespace: string,
    container: string,
    stdout: string,
    stderr: string,
    cluster: string = this.defaultClusterName
  ): Promise<true | Status> {
    const key = this.getLogKey(namespace, name, container);
    try {
      const resource = await this.getResource("Pod", name, namespace);
      if (resource.kind === "Status") {
        return createStatusFailure(`Unable to write logs: ${resource.message}`, resource.code, resource.reason);
      }
    } catch (error) {
      return createStatusFailure(`Resource Pod/${name} not found in namespace ${namespace}`, 404, "NotFound");
    }
    if (!this.logStore[cluster]) {
      this.logStore[cluster] = {};
    }

    if (!this.logStore[cluster][key]) {
      this.logStore[cluster][key] = {
        stdout: [],
        stderr: [],
        emitter: new EventEmitter()
      };
    }

    const entry = this.logStore[cluster][key];

    if (stdout) {
      this.appendLogLine(entry.stdout, stdout, 'stdout');
      entry.emitter.emit("stdout", stdout);
    }

    if (stderr) {
      this.appendLogLine(entry.stderr, stderr, 'stderr');
      entry.emitter.emit("stderr", stderr);
    }

    return true;
  }

  async readLogs(
    name: string,
    namespace: string,
    container: string,
    cluster: string = this.defaultClusterName,
    options?: { follow?: boolean; stderr?: boolean; stdout?: boolean }
  ): Promise<Readable | Status> {
    const key = this.getLogKey(namespace, name, container);
    const entry = this.logStore[cluster]?.[key];

    if (!entry) {
      return createStatusFailure(`No logs found for pod ${name} in namespace ${namespace}`, 404, "NotFound");
    }

    const stream = new Readable({ read() { } });

    const includeStdout = options?.stdout ?? true;
    const includeStderr = options?.stderr ?? true;

    const write = (line: string, type: "stdout" | "stderr") => {
      stream.push(`${type === "stderr" ? "\x1b[31;1m" : ""} ${line}\x1b[0m\n`);
    };
    const linesToWrite = []
    if (includeStdout) {
      linesToWrite.push(...entry.stdout);
    }
    if (includeStderr) {
      linesToWrite.push(...entry.stderr);
    }
    linesToWrite.sort((a, b) => a.timestamp.localeCompare(b.timestamp)).forEach((line) => {
      write(line.line, line.stream);
    });

    if (!options?.follow) {
      stream.push(null);
    } else {
      const onStdout = (data: string) => includeStdout && write(data, "stdout");
      const onStderr = (data: string) => includeStderr && write(data, "stderr");

      entry.emitter.on("stdout", onStdout);
      entry.emitter.on("stderr", onStderr);

      stream.on("close", () => {
        entry.emitter.off("stdout", onStdout);
        entry.emitter.off("stderr", onStderr);
      });
    }

    return stream;
  }

  // ---------------------------------------------------------------------------
  // Namespace resolution: cluster-scoped vs. namespaced
  // ---------------------------------------------------------------------------
  private resolveNamespace(kind: string, requestedNS: string | null): string | Status {
    const clusterScoped = isClusterScoped(kind);

    if (!clusterScoped && !requestedNS) {
      // default
      return "default";
    }
    if (clusterScoped) {
      return "";
    }
    return requestedNS || "default";
  }

  private getOrCreateNamespace(cluster: string, ns: string) {
    if (!this.data[cluster][ns]) {
      this.data[cluster][ns] = {};
    }
    return this.data[cluster][ns];
  }
  private getOrCreateCluster(cluster: string) {
    if (!this.data[cluster]) {
      this.data[cluster] = {};
    }
    return this.data[cluster];
  }
  private getNamespacedCollection(cluster: string, ns: string, kind: string) {
    const nsData = this.data[cluster][ns];
    if (!nsData) return undefined;
    return nsData[kind.toLowerCase()];
  }
  private getClusterCollection(cluster: string, kind: string) {
    const nsData = this.data[cluster][kind.toLowerCase()];
    if (!nsData) return undefined;
    return nsData;
  }

  private getOrCreateCollection(cluster: string, ns: string, kind: string) {
    const nsData = this.getOrCreateNamespace(cluster, ns);
    const key = kind.toLowerCase();
    if (!nsData[key]) {
      nsData[cluster][key] = {};
    }
    return nsData[cluster][key];
  }

  private getOrCreateClusterCollection(cluster: string, kind: string) {

    const key = kind.toLowerCase();
    if (!this.data[cluster][key]) {
      this.data[cluster][key] = {};
    }
    return this.data[cluster][key];
  }

  private generateResourceVersion(): string {
    return uuidv4();
  }

  // ---------------------------------------------------------------------------
  // Finalizer logic: if resource is marked for deletion (deletionTimestamp)
  // and has no finalizers left, remove it from store and emit DELETED.
  // ---------------------------------------------------------------------------
  private finalizeIfNeeded(cluster, ns: string, kind: string, name: string): boolean {

    const collection = this.getNamespacedCollection(cluster, ns, kind);
    if (!collection) return false;

    const existing = collection[name];
    if (!existing) return false;

    const finalizers = existing.metadata.finalizers || [];
    const deletionTimestamp = existing.metadata.deletionTimestamp;
    if (deletionTimestamp && finalizers.length === 0) {
      // remove now
      const copy = JSON.parse(JSON.stringify(existing));
      delete collection[name];
      this.emitWatchEvent(WatchEventType.DELETED, copy);
      return true;
    }

    return false;
  }

  // ---------------------------------------------------------------------------
  // GET RESOURCE
  // ---------------------------------------------------------------------------
  async getResource(
    kind: string,
    name: string,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName
  ): Promise<KubeResource | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const getCollection = () => {
      if (clusterScoped) {
        return this.getClusterCollection(cluster, kind);
      }

      const resolved = this.resolveNamespace(kind, namespace);
      if (typeof resolved !== "string") {
        return resolved; // Status object
      }

      return this.getNamespacedCollection(cluster, resolved, kind) || {};
    };

    const collection = getCollection();
    if (!collection || typeof collection !== "object" || !(name in collection)) {
      const location = clusterScoped ? "" : (namespace ?? "(cluster)");
      return createStatusFailure(
        `Resource ${kind}/${name} not found${clusterScoped ? "" : ` in ${location}`}`,
        404,
        "NotFound"
      );
    }

    return JSON.parse(JSON.stringify(collection[name]));
  }


  // ---------------------------------------------------------------------------
  // LIST RESOURCES
  // ---------------------------------------------------------------------------
  async listResources(
    kind: string,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    options?: ListOptions
  ): Promise<KubeList<KubeResource> | Status> {
    const clusterScoped = isClusterScoped(kind);
    const kindCapitalized = capitalize(kind);

    const getCollection = () => {
      if (clusterScoped) {
        if (namespace) {
          return createStatusFailure(
            `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
            400,
            "BadRequest"
          );
        }
        return this.getClusterCollection(cluster, kind) || {};
      }

      const resolved = this.resolveNamespace(kindCapitalized, namespace);
      if (typeof resolved !== "string") {
        return resolved; // Status object
      }

      return this.getNamespacedCollection(cluster, resolved, kind) || {};
    };

    const collection = getCollection();
    if (typeof collection !== "object") {
      return collection; // A Status object from getCollection()
    }

    let allItems = Object.values(collection);

    // Apply labelSelector filtering
    if (options?.labelSelector) {
      allItems = allItems.filter(item => matchesLabelSelector(item, options.labelSelector!));
    }

    // Apply fieldSelector filtering
    if (options?.fieldSelector) {
      allItems = allItems.filter(item => matchesFieldSelector(item, options.fieldSelector!));
    }

    // Sort for stable pagination
    allItems.sort((a, b) => {
      const aTime = a.metadata.creationTimestamp || "";
      const bTime = b.metadata.creationTimestamp || "";
      if (aTime === bTime) {
        return a.metadata.name.localeCompare(b.metadata.name);
      }
      return aTime.localeCompare(bTime);
    });

    // Pagination logic
    const parsedToken = parseContinueToken(options?.continue);
    const startIndex = parsedToken?.offset ?? 0;
    const limit = typeof options?.limit === "number" ? options.limit : allItems.length;
    const endIndex = Math.min(startIndex + limit, allItems.length);

    const paginated = allItems.slice(startIndex, endIndex);

    // Compute highest resourceVersion
    let highestRV = paginated.reduce((max, item) => {
      const rv = item.metadata.resourceVersion || "0";
      return rv.localeCompare(max) > 0 ? rv : max;
    }, "0");

    if (highestRV === "0") {
      highestRV = this.generateResourceVersion();
    }

    const nextContinue = endIndex < allItems.length
      ? createContinueToken(endIndex, highestRV)
      : undefined;

    return {
      kind: `${kindCapitalized}List`,
      apiVersion: "v1",
      metadata: {
        resourceVersion: highestRV,
        continue: nextContinue
      },
      items: paginated.map(item => JSON.parse(JSON.stringify(item)))
    };
  }


  // ---------------------------------------------------------------------------
  // CREATE RESOURCE
  // ---------------------------------------------------------------------------
  async createResource(
    resource: KubeResource,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName
  ): Promise<KubeResource | Status> {
    const { kind, metadata } = resource;

    if (!kind) {
      return createStatusFailure(`Missing resource.kind`, 400, "BadRequest");
    }

    if (!metadata?.name) {
      return createStatusFailure(`Missing resource.metadata.name`, 400, "BadRequest");
    }

    const clusterScoped = isClusterScoped(kind);
    const name = metadata.name;

    if (clusterScoped && (namespace || metadata.namespace)) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    // Determine final namespace (if applicable)
    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace ?? metadata.namespace ?? null);

    if (typeof resolvedNamespace !== "string") {
      return resolvedNamespace; // Status object
    }

    // Get cluster store and collection
    this.getOrCreateCluster(cluster);
    const collection = clusterScoped
      ? this.getOrCreateClusterCollection(cluster, kind)
      : this.getOrCreateCollection(cluster, resolvedNamespace, kind.toLowerCase());

    if (collection[name]) {
      const location = clusterScoped ? "(cluster)" : resolvedNamespace;
      return createStatusFailure(
        `Resource ${kind}/${name} already exists in ${location}`,
        409,
        "AlreadyExists"
      );
    }

    // Finalize metadata
    resource.metadata.namespace = clusterScoped ? undefined : resolvedNamespace;
    resource.metadata.creationTimestamp = new Date().toISOString();
    resource.metadata.resourceVersion = this.generateResourceVersion();

    // Store and emit event
    collection[name] = JSON.parse(JSON.stringify(resource));
    this.emitWatchEvent(WatchEventType.ADDED, resource, cluster);

    return JSON.parse(JSON.stringify(resource));
  }


  // ---------------------------------------------------------------------------
  // UPDATE RESOURCE
  // ---------------------------------------------------------------------------
  async updateResource(
    kind: string,
    name: string,
    resource: KubeResource,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    expectedResourceVersion?: string
  ): Promise<KubeResource | Status> {
    if (!resource || !resource.metadata) {
      return createStatusFailure(`Invalid resource object`, 400, "BadRequest");
    }

    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && (namespace || resource.metadata.namespace)) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace ?? resource.metadata.namespace ?? null);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace; // Return error status
    }

    // Ensure cluster data is initialized
    this.getOrCreateCluster(cluster);

    const collection = clusterScoped
      ? this.getOrCreateClusterCollection(cluster, kind)
      : this.getOrCreateCollection(cluster, resolvedNamespace as string, kind.toLowerCase());

    const existing = collection[name];
    if (!existing) {
      return createStatusFailure(
        `Resource ${kind}/${name} not found${clusterScoped ? "" : ` in ${resolvedNamespace}`}`,
        404,
        "NotFound"
      );
    }

    // Optimistic concurrency check
    if (expectedResourceVersion && existing.metadata.resourceVersion !== expectedResourceVersion) {
      return createStatusFailure(
        `Conflict: expected resourceVersion=${expectedResourceVersion}, got=${existing.metadata.resourceVersion}`,
        409,
        "Conflict"
      );
    }

    // Preserve immutable and system-managed fields
    resource.metadata.creationTimestamp = existing.metadata.creationTimestamp;
    if (existing.metadata.deletionTimestamp) {
      resource.metadata.deletionTimestamp = existing.metadata.deletionTimestamp;
    }
    if (!resource.metadata.finalizers) {
      resource.metadata.finalizers = existing.metadata.finalizers || [];
    }

    resource.metadata.resourceVersion = this.generateResourceVersion();
    resource.metadata.namespace = clusterScoped ? undefined : resolvedNamespace as string;

    collection[name] = JSON.parse(JSON.stringify(resource));
    this.emitWatchEvent(WatchEventType.MODIFIED, resource, cluster);

    if (!clusterScoped) {
      this.finalizeIfNeeded(cluster, resolvedNamespace as string, kind, name);
    }

    return JSON.parse(JSON.stringify(resource));
  }



  // ---------------------------------------------------------------------------
  // MERGE PATCH
  // ---------------------------------------------------------------------------
  async mergePatchResource(
    kind: string,
    name: string,
    patch: any,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    expectedResourceVersion?: string
  ): Promise<KubeResource | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace; // Status object
    }

    const collection = clusterScoped
      ? this.getClusterCollection(cluster, kind)
      : this.getNamespacedCollection(cluster, resolvedNamespace as string, kind);

    if (!collection || !collection[name]) {
      const location = clusterScoped ? "(cluster)" : resolvedNamespace;
      return createStatusFailure(`Resource ${kind}/${name} not found in ${location}`, 404, "NotFound");
    }

    const existing = collection[name];

    if (expectedResourceVersion && existing.metadata.resourceVersion !== expectedResourceVersion) {
      return createStatusFailure(
        `Conflict: expected resourceVersion=${expectedResourceVersion}, got=${existing.metadata.resourceVersion}`,
        409,
        "Conflict"
      );
    }

    const merged = merge(existing, patch);

    // Preserve immutable/system-managed metadata
    merged.metadata.resourceVersion = this.generateResourceVersion();
    merged.metadata.creationTimestamp = existing.metadata.creationTimestamp;
    merged.metadata.deletionTimestamp ??= existing.metadata.deletionTimestamp;
    merged.metadata.finalizers ??= existing.metadata.finalizers || [];
    merged.metadata.namespace = clusterScoped ? undefined : resolvedNamespace;

    const cloned = JSON.parse(JSON.stringify(merged));
    collection[name] = cloned;

    this.emitWatchEvent(WatchEventType.MODIFIED, cloned, cluster);

    if (!clusterScoped) {
      this.finalizeIfNeeded(cluster, resolvedNamespace as string, kind, name);
    }

    return JSON.parse(JSON.stringify(cloned));
  }


  // ---------------------------------------------------------------------------
  // JSON PATCH
  // ---------------------------------------------------------------------------
  async jsonPatchResource(
    kind: string,
    name: string,
    patch: any,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    expectedResourceVersion?: string
  ): Promise<KubeResource | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace; // Status object
    }

    const collection = clusterScoped
      ? this.getClusterCollection(cluster, kind)
      : this.getNamespacedCollection(cluster, resolvedNamespace as string, kind);

    if (!collection || !collection[name]) {
      const location = clusterScoped ? "(cluster)" : resolvedNamespace;
      return createStatusFailure(`Resource ${kind}/${name} not found in ${location}`, 404, "NotFound");
    }

    const existing = collection[name];

    if (expectedResourceVersion && existing.metadata.resourceVersion !== expectedResourceVersion) {
      return createStatusFailure(
        `Conflict: expected resourceVersion=${expectedResourceVersion}, got=${existing.metadata.resourceVersion}`,
        409,
        "Conflict"
      );
    }

    const patched = applyPatch(existing, patch).newDocument;

    // Preserve and set metadata fields
    patched.metadata.resourceVersion = this.generateResourceVersion();
    patched.metadata.creationTimestamp = existing.metadata.creationTimestamp;
    patched.metadata.deletionTimestamp ??= existing.metadata.deletionTimestamp;
    patched.metadata.finalizers ??= existing.metadata.finalizers || [];
    patched.metadata.namespace = clusterScoped ? undefined : resolvedNamespace;

    const cloned = JSON.parse(JSON.stringify(patched));
    collection[name] = cloned;

    this.emitWatchEvent(WatchEventType.MODIFIED, cloned, cluster);

    if (!clusterScoped) {
      this.finalizeIfNeeded(cluster, resolvedNamespace as string, kind, name);
    }

    return JSON.parse(JSON.stringify(cloned));
  }

  // ---------------------------------------------------------------------------
  // SUBRESOURCE (status, scale, etc.)
  // ---------------------------------------------------------------------------
  async updateSubresource(
    kind: string,
    name: string,
    subresource: string,
    patch: any,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    expectedResourceVersion?: string
  ): Promise<KubeResource | KubeScale | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace;
    }

    const collection = clusterScoped
      ? this.getClusterCollection(cluster, kind)
      : this.getNamespacedCollection(cluster, resolvedNamespace as string, kind);

    if (!collection || !collection[name]) {
      const location = clusterScoped ? "(cluster)" : resolvedNamespace;
      return createStatusFailure(`Resource ${kind}/${name} not found in ${location}`, 404, "NotFound");
    }

    const existing = collection[name];

    if (expectedResourceVersion && existing.metadata.resourceVersion !== expectedResourceVersion) {
      return createStatusFailure(
        `Conflict: expected resourceVersion=${expectedResourceVersion}, got=${existing.metadata.resourceVersion}`,
        409,
        "Conflict"
      );
    }

    let modified: KubeResource = { ...existing };

    if (subresource === "status") {
      modified.status = merge(existing.status || {}, patch);
    } else if (subresource === "scale") {
      if (patch?.spec?.replicas != null && typeof patch.spec.replicas === "number") {
        modified.spec = { ...(existing.spec || {}), replicas: patch.spec.replicas };
        modified.status = { ...(existing.status || {}), replicas: patch.spec.replicas };
      }

      modified.metadata.resourceVersion = this.generateResourceVersion();
      modified.metadata.namespace = clusterScoped ? undefined : resolvedNamespace as string;

      const cloned = JSON.parse(JSON.stringify(modified));
      collection[name] = cloned;
      this.emitWatchEvent(WatchEventType.MODIFIED, cloned, cluster);

      if (!clusterScoped) {
        this.finalizeIfNeeded(cluster, resolvedNamespace as string, kind, name);
      }

      const scale: KubeScale = {
        apiVersion: "autoscaling/v1",
        kind: "Scale",
        metadata: {
          name: cloned.metadata.name,
          namespace: cloned.metadata.namespace
        },
        spec: {
          replicas: cloned.spec?.replicas
        },
        status: {
          replicas: cloned.status?.replicas
        }
      };
      return scale;
    } else {
      modified[subresource] = merge(existing[subresource] || {}, patch);
    }

    modified.metadata.resourceVersion = this.generateResourceVersion();
    modified.metadata.namespace = clusterScoped ? undefined : resolvedNamespace as string;

    const finalClone = JSON.parse(JSON.stringify(modified));
    collection[name] = finalClone;

    this.emitWatchEvent(WatchEventType.MODIFIED, finalClone, cluster);

    if (!clusterScoped) {
      this.finalizeIfNeeded(cluster, resolvedNamespace as string, kind, name);
    }

    return JSON.parse(JSON.stringify(finalClone));
  }


  // ---------------------------------------------------------------------------
  // DELETE RESOURCE
  // ---------------------------------------------------------------------------
  async deleteResource(
    kind: string,
    name: string,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName
  ): Promise<true | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace;
    }

    const collection = clusterScoped
      ? this.getClusterCollection(cluster, kind)
      : this.getNamespacedCollection(cluster, resolvedNamespace as string, kind);

    if (!collection || !collection[name]) {
      const location = clusterScoped ? "(cluster)" : resolvedNamespace;
      return createStatusFailure(`Resource ${kind}/${name} not found in ${location}`, 404, "NotFound");
    }

    const existing = collection[name];
    const finalizers = existing.metadata.finalizers || [];

    if (finalizers.length === 0) {
      const deletedCopy = JSON.parse(JSON.stringify(existing));
      delete collection[name];
      this.emitWatchEvent(WatchEventType.DELETED, deletedCopy, cluster);
      return true;
    }

    if (!existing.metadata.deletionTimestamp) {
      existing.metadata.deletionTimestamp = new Date().toISOString();
      existing.metadata.resourceVersion = this.generateResourceVersion();
      const updatedCopy = JSON.parse(JSON.stringify(existing));
      collection[name] = updatedCopy;
      this.emitWatchEvent(WatchEventType.MODIFIED, updatedCopy, cluster);
    }

    return true;
  }


  // ---------------------------------------------------------------------------
  // DELETE ALL RESOURCES
  // ---------------------------------------------------------------------------
  async deleteAllResources(
    kind: string,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    opts?: { labelSelector?: string; fieldSelector?: string }
  ): Promise<true | Status> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      return createStatusFailure(
        `Resource ${kind} is cluster-scoped, so namespace must be empty.`,
        400,
        "BadRequest"
      );
    }

    const resolvedNamespace = clusterScoped
      ? null
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return resolvedNamespace;
    }

    const collection = clusterScoped
      ? this.getClusterCollection(cluster, kind)
      : this.getNamespacedCollection(cluster, resolvedNamespace as string, kind);

    if (!collection) {
      return true; // No resources to delete
    }

    let resources = Object.values(collection);

    if (opts?.labelSelector) {
      resources = resources.filter(r => matchesLabelSelector(r, opts.labelSelector!));
    }

    if (opts?.fieldSelector) {
      resources = resources.filter(r => matchesFieldSelector(r, opts.fieldSelector!));
    }

    for (const r of resources) {
      const name = r.metadata.name;
      const finalizers = r.metadata.finalizers || [];

      if (finalizers.length === 0) {
        const deletedCopy = JSON.parse(JSON.stringify(r));
        delete collection[name];
        this.emitWatchEvent(WatchEventType.DELETED, deletedCopy, cluster);
      } else {
        if (!r.metadata.deletionTimestamp) {
          r.metadata.deletionTimestamp = new Date().toISOString();
          r.metadata.resourceVersion = this.generateResourceVersion();
          const updatedCopy = JSON.parse(JSON.stringify(r));
          collection[name] = updatedCopy;
          this.emitWatchEvent(WatchEventType.MODIFIED, updatedCopy, cluster);
        }
      }
    }

    return true;
  }

  // ---------------------------------------------------------------------------
  // WATCH RESOURCES
  // ---------------------------------------------------------------------------
  async watchResources(
    kind: string,
    namespace: string | null = null,
    cluster: string = this.defaultClusterName,
    options?: WatchOptions,
    onEvent?: (eventType: WatchEventType, resource: KubeResource | Status) => void
  ): Promise<() => void> {
    const clusterScoped = isClusterScoped(kind);

    if (clusterScoped && namespace) {
      // invalid usage: cluster-scoped resources can't be namespaced
      return async () => { };
    }

    const resolvedNamespace = clusterScoped
      ? `__cluster__${cluster}`
      : this.resolveNamespace(kind, namespace);

    if (!clusterScoped && typeof resolvedNamespace !== "string") {
      return async () => { };
    }

    const eventName = `${resolvedNamespace}:${kind.toLowerCase()}`;

    const handler = (evtType: WatchEventType, resource: KubeResource) => {
      const { labelSelector, fieldSelector, resourceVersion } = options ?? {};

      if (labelSelector && !matchesLabelSelector(resource, labelSelector)) return;
      if (fieldSelector && !matchesFieldSelector(resource, fieldSelector)) return;
      if (resourceVersion && resource.metadata.resourceVersion! <= resourceVersion) return;

      onEvent?.(evtType, JSON.parse(JSON.stringify(resource)));
    };

    this.eventEmitter.on(eventName, handler);

    // Emit initial ADDED events for matching items
    const listResp = await this.listResources(kind, namespace, cluster, {
      labelSelector: options?.labelSelector,
      fieldSelector: options?.fieldSelector
    });

    if ("items" in listResp) {
      const minVersion = options?.resourceVersion;
      for (const item of listResp.items) {
        if (!minVersion || item.metadata.resourceVersion! > minVersion) {
          onEvent?.(WatchEventType.ADDED, JSON.parse(JSON.stringify(item)));
        }
      }
    }

    // Return unsubscribe function
    return () => {
      this.eventEmitter.removeListener(eventName, handler);
    };
  }


  // ---------------------------------------------------------------------------
  // INTERNAL: EMIT WATCH EVENTS
  // ---------------------------------------------------------------------------
  private emitWatchEvent(type: WatchEventType, resource: KubeResource, cluster: string = this.defaultClusterName) {
    const ns = resource.metadata.namespace || `__cluster__${cluster}`;
    const eventName = `${ns}:${resource.kind.toLowerCase()}`;
    this.eventEmitter.emit(eventName, type, resource);
  }
}
